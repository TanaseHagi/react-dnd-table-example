{"version":3,"sources":["ItemTypes.ts","DraggableCard.tsx","example.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ItemTypes","DraggableCard","_ref","id","index","moveCard","parentIndex","children","color","type","ref","useRef","_useDrop","useDrop","accept","concat","hover","item","monitor","current","dragIndex","hoverIndex","hoverBoundingRect","getBoundingClientRect","hoverMiddleY","bottom","top","hoverClientY","getClientOffset","y","drop","Object","slicedToArray","_useDrag","useDrag","collect","isDragging","_useDrag2","drag","style","width","trStyle","border","padding","marginBottom","backgroundColor","cursor","Container","props","_useState","useState","text","_useState2","cards","setCards","useCallback","dragCard","update","$splice","react_default","a","createElement","src_DraggableCard","BODY","opacity","objectSpread","fontWeight","map","card","cardIndex","key","ROW","App","bodys","setBodys","body","example","Boolean","window","location","hostname","match","ReactDOM","render","esm","backend","HTML5Backend","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7ff0fc11.chunk.js","sourcesContent":["export enum ItemTypes {\n    BODY = \"BODY\",\n    ROW = \"ROW\",\n}\n","import React, { useRef, ReactElement } from 'react'\nimport { useDrag, useDrop, DropTargetMonitor } from 'react-dnd'\nimport { XYCoord } from 'dnd-core'\nimport { ItemTypes } from './ItemTypes';\n\nexport interface DraggableCardProps {\n  id: any;\n  index: number;\n  moveCard: (dragIndex: number, hoverIndex: number) => void;\n  parentIndex: number;\n  color: string;\n  type: ItemTypes;\n  children(ref: React.RefObject<any>, isDragging: boolean): ReactElement | null;\n}\n\ninterface DragItem {\n  index: number;\n  id: string;\n  type: string;\n}\n\nconst DraggableCard: React.FC<DraggableCardProps> = ({ id, index, moveCard, parentIndex, color, children, type }) => {\n  const ref = useRef<HTMLTableRowElement>(null)\n  const [, drop] = useDrop({\n    accept: `${type}-${parentIndex}`,\n    hover(item: DragItem, monitor: DropTargetMonitor) {\n      if (!ref.current) {\n        return\n      }\n      const dragIndex = item.index\n      const hoverIndex = index\n\n      // Don't replace items with themselves\n      if (dragIndex === hoverIndex) {\n        return\n      }\n\n      // Determine rectangle on screen\n      const hoverBoundingRect = ref.current!.getBoundingClientRect()\n\n      // Get vertical middle\n      const hoverMiddleY =\n        (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2\n\n      // Determine mouse position\n      const clientOffset = monitor.getClientOffset()\n\n      // Get pixels to the top\n      const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top\n\n      // Only perform the move when the mouse has crossed half of the items height\n      // When dragging downwards, only move when the cursor is below 50%\n      // When dragging upwards, only move when the cursor is above 50%\n\n      // Dragging downwards\n      if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {\n        return\n      }\n\n      // Dragging upwards\n      if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {\n        return\n      }\n\n      // Time to actually perform the action\n      moveCard(dragIndex, hoverIndex)\n\n      // Note: we're mutating the monitor item here!\n      // Generally it's better to avoid mutations,\n      // but it's good here for the sake of performance\n      // to avoid expensive index searches.\n      item.index = hoverIndex\n    },\n  })\n\n  const [{ isDragging }, drag] = useDrag({\n    item: { type: `${type}-${parentIndex}`, id, index },\n    collect: (monitor: any) => ({\n      isDragging: monitor.isDragging(),\n    }),\n  })\n\n  drag(drop(ref))\n\n  return typeof children === \"function\"\n    ? children(ref, isDragging)\n    : null;\n}\n\nexport default DraggableCard\n","import React, { useState, useCallback } from 'react'\nimport DraggableCard from \"./DraggableCard\";\nimport update from 'immutability-helper'\nimport { ItemTypes } from './ItemTypes';\n\nconst style = {\n  width: 400,\n}\n\nconst trStyle = {\n  border: '1px dashed gray',\n  padding: '0.5rem 1rem',\n  marginBottom: '.5rem',\n  backgroundColor: 'white',\n  cursor: 'move',\n}\n\nexport interface ContainerProps {\n  index: number;\n  id: any;\n  color: string;\n  moveCard: (dragIndex: number, hoverIndex: number) => void;\n}\n\nexport interface ContainerState {\n  cards: Array<{\n    id: number\n    text: string\n  }>\n}\n\nconst Container: React.FC<ContainerProps> = (props) => {\n  {\n    const [cards, setCards] = useState([\n      {\n        id: 1,\n        text: 'Write a cool JS library',\n      },\n      {\n        id: 2,\n        text: 'Make it generic enough',\n      },\n      {\n        id: 3,\n        text: 'Write README',\n      },\n      {\n        id: 4,\n        text: 'Create some examples',\n      },\n      {\n        id: 5,\n        text:\n          'Spam in Twitter and IRC to promote it (note that this element is taller than the others)',\n      },\n      {\n        id: 6,\n        text: '???',\n      },\n      {\n        id: 7,\n        text: 'PROFIT',\n      },\n    ])\n\n    const moveCard = useCallback(\n      (dragIndex: number, hoverIndex: number) => {\n        const dragCard = cards[dragIndex]\n        setCards(\n          update(cards, {\n            $splice: [[dragIndex, 1], [hoverIndex, 0, dragCard]],\n          }),\n        )\n      },\n      [cards],\n    )\n\n    return (\n      <DraggableCard\n        index={props.index}\n        id={props.id}\n        moveCard={props.moveCard}\n        parentIndex={-1}\n        color={props.color}\n        type={ItemTypes.BODY}\n      >\n        {(ref, isDragging) => {\n          const opacity = isDragging ? 0 : 1;\n          return (\n            <tbody ref={ref} style={{ backgroundColor: props.color, ...style, opacity }}>\n              <tr>\n                <td style={{ fontWeight: \"bold\" }}>Header {props.index + 1}</td>\n                <td>some</td>\n                <td>column</td>\n                <td>extra</td>\n              </tr>\n              {cards.map((card, cardIndex) =>\n                <DraggableCard\n                  key={card.id}\n                  index={cardIndex}\n                  id={card.id}\n                  moveCard={moveCard}\n                  parentIndex={props.index}\n                  color={props.color}\n                  type={ItemTypes.ROW}\n                >\n                  {(ref, isDragging) => {\n                    const opacity = isDragging ? 0 : 1;\n                    return (\n                      <tr ref={ref} style={{ backgroundColor: props.color, ...trStyle, opacity }}>\n                        <td style={{ backgroundColor: props.color }}>{card.text}</td>\n                        <td style={{ backgroundColor: props.color }}>111</td>\n                        <td style={{ backgroundColor: props.color }}>222</td>\n                        <td style={{ backgroundColor: props.color }}>333</td>\n                      </tr>\n                    )\n                  }}\n                </DraggableCard>\n              )}\n            </tbody>\n          )\n        }}\n      </DraggableCard>\n    )\n  }\n}\n\nexport default Container\n","import React, { useState, useCallback } from 'react'\nimport Example from './example'\nimport update from 'immutability-helper'\n\nfunction App() {\n  // eslint-disable-next-line\n  const [bodys, setBodys] = useState([\n    {\n      id: 1,\n      color: \"lightgray\"\n    },\n    {\n      id: 2,\n      color: \"skyblue\"\n    }\n  ]);\n\n  const moveCard = useCallback(\n    (dragIndex: number, hoverIndex: number) => {\n      const dragCard = bodys[dragIndex]\n      setBodys(\n        update(bodys, {\n          $splice: [[dragIndex, 1], [hoverIndex, 0, dragCard]],\n        }),\n      )\n    },\n    [bodys],\n  )\n\n  return (\n    <table>\n        {bodys.map((body, index) => {\n          return (\n            <Example key={body.id} color={body.color} index={index} id={body.id} moveCard={moveCard} />\n          );\n        })}\n    </table>\n  );\n\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { DragDropContextProvider } from 'react-dnd'\nimport HTML5Backend from 'react-dnd-html5-backend'\n\n// https://github.com/react-dnd/react-dnd/issues/740#issuecomment-299686690\nReactDOM.render(\n    <DragDropContextProvider backend={HTML5Backend}>\n        <App />\n    </DragDropContextProvider>\n    , document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}